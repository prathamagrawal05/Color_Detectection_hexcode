{"ast":null,"code":"import nearestVector from 'ml-nearest-vector';\n/**\n * Calculates the distance matrix for a given array of points\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {function} distance - Distance function to use between the points\n * @return {Array<Array<number>>} - matrix with the distance values\n */\nexport function calculateDistanceMatrix(data, distance) {\n  let distanceMatrix = new Array(data.length);\n  for (let i = 0; i < data.length; ++i) {\n    for (let j = i; j < data.length; ++j) {\n      if (!distanceMatrix[i]) {\n        distanceMatrix[i] = new Array(data.length);\n      }\n      if (!distanceMatrix[j]) {\n        distanceMatrix[j] = new Array(data.length);\n      }\n      const dist = distance(data[i], data[j]);\n      distanceMatrix[i][j] = dist;\n      distanceMatrix[j][i] = dist;\n    }\n  }\n  return distanceMatrix;\n}\n/**\n * Updates the cluster identifier based in the new data\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {function} distance - Distance function to use between the points\n * @return {Array} the cluster identifier for each data dot\n */\nexport function updateClusterID(data, centers, clusterID, distance) {\n  for (let i = 0; i < data.length; i++) {\n    clusterID[i] = nearestVector(centers, data[i], {\n      distanceFunction: distance\n    });\n  }\n  return clusterID;\n}\n/**\n * Update the center values based in the new configurations of the clusters\n * @ignore\n * @param {Array<Array<number>>} prevCenters - Centroids from the previous iteration\n * @param {Array <Array <number>>} data - the [x,y,z,...] points to cluster\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @return {Array} he K centers in format [x,y,z,...]\n */\nexport function updateCenters(prevCenters, data, clusterID, K) {\n  const nDim = data[0].length;\n  // copy previous centers\n  let centers = new Array(K);\n  let centersLen = new Array(K);\n  for (let i = 0; i < K; i++) {\n    centers[i] = new Array(nDim);\n    centersLen[i] = 0;\n    for (let j = 0; j < nDim; j++) {\n      centers[i][j] = 0;\n    }\n  }\n  // add the value for all dimensions of the point\n  for (let l = 0; l < data.length; l++) {\n    centersLen[clusterID[l]]++;\n    for (let dim = 0; dim < nDim; dim++) {\n      centers[clusterID[l]][dim] += data[l][dim];\n    }\n  }\n  // divides by length\n  for (let id = 0; id < K; id++) {\n    for (let d = 0; d < nDim; d++) {\n      if (centersLen[id]) {\n        centers[id][d] /= centersLen[id];\n      } else {\n        centers[id][d] = prevCenters[id][d];\n      }\n    }\n  }\n  return centers;\n}\n/**\n * The centers have moved more than the tolerance value?\n * @ignore\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} oldCenters - the K old centers in format [x,y,z,...]\n * @param {function} distanceFunction - Distance function to use between the points\n * @param {number} tolerance - Allowed distance for the centroids to move\n * @return {boolean}\n */\nexport function hasConverged(centers, oldCenters, distanceFunction, tolerance) {\n  for (let i = 0; i < centers.length; i++) {\n    if (distanceFunction(centers[i], oldCenters[i]) > tolerance) {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["nearestVector","calculateDistanceMatrix","data","distance","distanceMatrix","Array","length","i","j","dist","updateClusterID","centers","clusterID","distanceFunction","updateCenters","prevCenters","K","nDim","centersLen","l","dim","id","d","hasConverged","oldCenters","tolerance"],"sources":["/Users/ashraygattani/Documents/most/my-react-app/node_modules/ml-kmeans/src/utils.ts"],"sourcesContent":["import nearestVector from 'ml-nearest-vector';\n\n/**\n * Calculates the distance matrix for a given array of points\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {function} distance - Distance function to use between the points\n * @return {Array<Array<number>>} - matrix with the distance values\n */\nexport function calculateDistanceMatrix(\n  data: number[][],\n  distance: (a: number[], b: number[]) => number,\n) {\n  let distanceMatrix: number[][] = new Array(data.length);\n  for (let i = 0; i < data.length; ++i) {\n    for (let j = i; j < data.length; ++j) {\n      if (!distanceMatrix[i]) {\n        distanceMatrix[i] = new Array(data.length);\n      }\n      if (!distanceMatrix[j]) {\n        distanceMatrix[j] = new Array(data.length);\n      }\n      const dist = distance(data[i], data[j]);\n      distanceMatrix[i][j] = dist;\n      distanceMatrix[j][i] = dist;\n    }\n  }\n  return distanceMatrix;\n}\n\n/**\n * Updates the cluster identifier based in the new data\n * @ignore\n * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {function} distance - Distance function to use between the points\n * @return {Array} the cluster identifier for each data dot\n */\nexport function updateClusterID(\n  data: number[][],\n  centers: number[][],\n  clusterID: number[],\n  distance: (a: number[], b: number[]) => number,\n): number[] {\n  for (let i = 0; i < data.length; i++) {\n    clusterID[i] = nearestVector(centers, data[i], {\n      distanceFunction: distance,\n    });\n  }\n  return clusterID;\n}\n\n/**\n * Update the center values based in the new configurations of the clusters\n * @ignore\n * @param {Array<Array<number>>} prevCenters - Centroids from the previous iteration\n * @param {Array <Array <number>>} data - the [x,y,z,...] points to cluster\n * @param {Array <number>} clusterID - the cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @return {Array} he K centers in format [x,y,z,...]\n */\nexport function updateCenters(\n  prevCenters: number[][],\n  data: number[][],\n  clusterID: number[],\n  K: number,\n): number[][] {\n  const nDim = data[0].length;\n\n  // copy previous centers\n  let centers = new Array<number[]>(K);\n  let centersLen = new Array<number>(K);\n  for (let i = 0; i < K; i++) {\n    centers[i] = new Array<number>(nDim);\n    centersLen[i] = 0;\n    for (let j = 0; j < nDim; j++) {\n      centers[i][j] = 0;\n    }\n  }\n\n  // add the value for all dimensions of the point\n  for (let l = 0; l < data.length; l++) {\n    centersLen[clusterID[l]]++;\n    for (let dim = 0; dim < nDim; dim++) {\n      centers[clusterID[l]][dim] += data[l][dim];\n    }\n  }\n\n  // divides by length\n  for (let id = 0; id < K; id++) {\n    for (let d = 0; d < nDim; d++) {\n      if (centersLen[id]) {\n        centers[id][d] /= centersLen[id];\n      } else {\n        centers[id][d] = prevCenters[id][d];\n      }\n    }\n  }\n  return centers;\n}\n\n/**\n * The centers have moved more than the tolerance value?\n * @ignore\n * @param {Array<Array<number>>} centers - the K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} oldCenters - the K old centers in format [x,y,z,...]\n * @param {function} distanceFunction - Distance function to use between the points\n * @param {number} tolerance - Allowed distance for the centroids to move\n * @return {boolean}\n */\nexport function hasConverged(\n  centers: number[][],\n  oldCenters: number[][],\n  distanceFunction: (a: number[], b: number[]) => number,\n  tolerance: number,\n): boolean {\n  for (let i = 0; i < centers.length; i++) {\n    if (distanceFunction(centers[i], oldCenters[i]) > tolerance) {\n      return false;\n    }\n  }\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}