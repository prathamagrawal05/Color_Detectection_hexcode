{"ast":null,"code":"import { squaredEuclidean } from 'ml-distance-euclidean';\nimport { Matrix } from 'ml-matrix';\nimport Random from 'ml-random';\n/**\n * Choose K different random points from the original data\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\nexport function random(data, K, seed) {\n  const random = new Random(seed);\n  return random.choice(data, {\n    size: K\n  });\n}\n/**\n * Chooses the most distant points to a first random pick\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {Array<Array<number>>} distanceMatrix - matrix with the distance values\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\nexport function mostDistant(data, K, distanceMatrix, seed) {\n  const random = new Random(seed);\n  let ans = new Array(K);\n  // chooses a random point as initial cluster\n  ans[0] = Math.floor(random.random() * data.length);\n  if (K > 1) {\n    // chooses the more distant point\n    let maxDist = {\n      dist: -1,\n      index: -1\n    };\n    for (let l = 0; l < data.length; ++l) {\n      if (distanceMatrix[ans[0]][l] > maxDist.dist) {\n        maxDist.dist = distanceMatrix[ans[0]][l];\n        maxDist.index = l;\n      }\n    }\n    ans[1] = maxDist.index;\n    if (K > 2) {\n      // chooses the set of points that maximises the min distance\n      for (let k = 2; k < K; ++k) {\n        let center = {\n          dist: -1,\n          index: -1\n        };\n        for (let m = 0; m < data.length; ++m) {\n          // minimum distance to centers\n          let minDistCent = {\n            dist: Number.MAX_VALUE,\n            index: -1\n          };\n          for (let n = 0; n < k; ++n) {\n            if (distanceMatrix[n][m] < minDistCent.dist && !ans.includes(m)) {\n              minDistCent = {\n                dist: distanceMatrix[n][m],\n                index: m\n              };\n            }\n          }\n          if (minDistCent.dist !== Number.MAX_VALUE && minDistCent.dist > center.dist) {\n            center = {\n              ...minDistCent\n            };\n          }\n        }\n        ans[k] = center.index;\n      }\n    }\n  }\n  return ans.map(index => data[index]);\n}\n// Implementation inspired from scikit\nexport function kmeanspp(X, K, options = {}) {\n  const m = new Matrix(X);\n  const nSamples = m.rows;\n  const random = new Random(options.seed);\n  // Set the number of trials\n  const centers = [];\n  const localTrials = options.localTrials || 2 + Math.floor(Math.log(K));\n  // Pick the first center at random from the dataset\n  const firstCenterIdx = random.randInt(nSamples);\n  centers.push(m.getRow(firstCenterIdx));\n  // Init closest distances\n  let closestDistSquared = new Matrix(1, m.rows);\n  for (let i = 0; i < m.rows; i++) {\n    closestDistSquared.set(0, i, squaredEuclidean(m.getRow(i), centers[0]));\n  }\n  let cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n  const factor = 1 / cumSumClosestDistSquared[0][nSamples - 1];\n  let probabilities = Matrix.mul(closestDistSquared, factor);\n  // Iterate over the remaining centers\n  for (let i = 1; i < K; i++) {\n    const candidateIdx = random.choice(nSamples, {\n      replace: true,\n      size: localTrials,\n      probabilities: probabilities.getRow(0)\n    });\n    const candidates = m.selection(candidateIdx, range(m.columns));\n    const distanceToCandidates = euclideanDistances(candidates, m);\n    let bestCandidate = Infinity;\n    let bestPot = Infinity;\n    let bestDistSquared = closestDistSquared;\n    for (let j = 0; j < localTrials; j++) {\n      const newDistSquared = Matrix.min(closestDistSquared, [distanceToCandidates.getRow(j)]);\n      const newPot = newDistSquared.sum();\n      if (newPot < bestPot) {\n        bestCandidate = candidateIdx[j];\n        bestPot = newPot;\n        bestDistSquared = newDistSquared;\n      }\n    }\n    centers[i] = m.getRow(bestCandidate);\n    closestDistSquared = bestDistSquared;\n    cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n    probabilities = Matrix.mul(closestDistSquared, 1 / cumSumClosestDistSquared[0][nSamples - 1]);\n  }\n  return centers;\n}\nfunction euclideanDistances(A, B) {\n  const result = new Matrix(A.rows, B.rows);\n  for (let i = 0; i < A.rows; i++) {\n    for (let j = 0; j < B.rows; j++) {\n      result.set(i, j, squaredEuclidean(A.getRow(i), B.getRow(j)));\n    }\n  }\n  return result;\n}\nfunction range(l) {\n  let r = [];\n  for (let i = 0; i < l; i++) {\n    r.push(i);\n  }\n  return r;\n}\nfunction cumSum(arr) {\n  let cumSum = [arr[0]];\n  for (let i = 1; i < arr.length; i++) {\n    cumSum[i] = cumSum[i - 1] + arr[i];\n  }\n  return cumSum;\n}","map":{"version":3,"names":["squaredEuclidean","Matrix","Random","random","data","K","seed","choice","size","mostDistant","distanceMatrix","ans","Array","Math","floor","length","maxDist","dist","index","l","k","center","m","minDistCent","Number","MAX_VALUE","n","includes","map","kmeanspp","X","options","nSamples","rows","centers","localTrials","log","firstCenterIdx","randInt","push","getRow","closestDistSquared","i","set","cumSumClosestDistSquared","cumSum","factor","probabilities","mul","candidateIdx","replace","candidates","selection","range","columns","distanceToCandidates","euclideanDistances","bestCandidate","Infinity","bestPot","bestDistSquared","j","newDistSquared","min","newPot","sum","A","B","result","r","arr"],"sources":["/Users/ashraygattani/Documents/most/my-react-app/node_modules/ml-kmeans/src/initialization.ts"],"sourcesContent":["import { squaredEuclidean } from 'ml-distance-euclidean';\nimport { Matrix } from 'ml-matrix';\nimport Random from 'ml-random';\n\n/**\n * Choose K different random points from the original data\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\nexport function random(data: number[][], K: number, seed?: number) {\n  const random = new Random(seed);\n  return random.choice(data, { size: K });\n}\n\n/**\n * Chooses the most distant points to a first random pick\n * @ignore\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - number of clusters\n * @param {Array<Array<number>>} distanceMatrix - matrix with the distance values\n * @param {number} seed - seed for random number generation\n * @return {Array<Array<number>>} - Initial random points\n */\nexport function mostDistant(\n  data: number[][],\n  K: number,\n  distanceMatrix: number[][],\n  seed?: number,\n): number[][] {\n  const random = new Random(seed);\n  let ans = new Array<number>(K);\n  // chooses a random point as initial cluster\n  ans[0] = Math.floor(random.random() * data.length);\n\n  if (K > 1) {\n    // chooses the more distant point\n    let maxDist = { dist: -1, index: -1 };\n    for (let l = 0; l < data.length; ++l) {\n      if (distanceMatrix[ans[0]][l] > maxDist.dist) {\n        maxDist.dist = distanceMatrix[ans[0]][l];\n        maxDist.index = l;\n      }\n    }\n    ans[1] = maxDist.index;\n\n    if (K > 2) {\n      // chooses the set of points that maximises the min distance\n      for (let k = 2; k < K; ++k) {\n        let center = { dist: -1, index: -1 };\n        for (let m = 0; m < data.length; ++m) {\n          // minimum distance to centers\n          let minDistCent = { dist: Number.MAX_VALUE, index: -1 };\n          for (let n = 0; n < k; ++n) {\n            if (distanceMatrix[n][m] < minDistCent.dist && !ans.includes(m)) {\n              minDistCent = {\n                dist: distanceMatrix[n][m],\n                index: m,\n              };\n            }\n          }\n\n          if (\n            minDistCent.dist !== Number.MAX_VALUE &&\n            minDistCent.dist > center.dist\n          ) {\n            center = { ...minDistCent };\n          }\n        }\n\n        ans[k] = center.index;\n      }\n    }\n  }\n\n  return ans.map((index) => data[index]);\n}\n\ninterface Options {\n  seed: number;\n  localTrials: number;\n}\n\n// Implementation inspired from scikit\nexport function kmeanspp(\n  X: number[][],\n  K: number,\n  options: Partial<Options> = {},\n) {\n  const m = new Matrix(X);\n  const nSamples = m.rows;\n  const random = new Random(options.seed);\n\n  // Set the number of trials\n  const centers: number[][] = [];\n  const localTrials = options.localTrials || 2 + Math.floor(Math.log(K));\n\n  // Pick the first center at random from the dataset\n  const firstCenterIdx = random.randInt(nSamples);\n  centers.push(m.getRow(firstCenterIdx));\n\n  // Init closest distances\n  let closestDistSquared = new Matrix(1, m.rows);\n  for (let i = 0; i < m.rows; i++) {\n    closestDistSquared.set(0, i, squaredEuclidean(m.getRow(i), centers[0]));\n  }\n  let cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n  const factor = 1 / cumSumClosestDistSquared[0][nSamples - 1];\n  let probabilities: Matrix = Matrix.mul(closestDistSquared, factor);\n\n  // Iterate over the remaining centers\n  for (let i = 1; i < K; i++) {\n    const candidateIdx: number[] = random.choice(nSamples, {\n      replace: true,\n      size: localTrials,\n      probabilities: probabilities.getRow(0),\n    });\n\n    const candidates = m.selection(candidateIdx, range(m.columns));\n    const distanceToCandidates = euclideanDistances(candidates, m);\n\n    let bestCandidate = Infinity;\n    let bestPot = Infinity;\n    let bestDistSquared = closestDistSquared;\n\n    for (let j = 0; j < localTrials; j++) {\n      const newDistSquared = Matrix.min(closestDistSquared, [\n        distanceToCandidates.getRow(j),\n      ]);\n      const newPot = newDistSquared.sum();\n      if (newPot < bestPot) {\n        bestCandidate = candidateIdx[j];\n        bestPot = newPot;\n        bestDistSquared = newDistSquared;\n      }\n    }\n    centers[i] = m.getRow(bestCandidate);\n    closestDistSquared = bestDistSquared;\n    cumSumClosestDistSquared = [cumSum(closestDistSquared.getRow(0))];\n    probabilities = Matrix.mul(\n      closestDistSquared,\n      1 / cumSumClosestDistSquared[0][nSamples - 1],\n    );\n  }\n  return centers;\n}\n\nfunction euclideanDistances(A: Matrix, B: Matrix) {\n  const result = new Matrix(A.rows, B.rows);\n  for (let i = 0; i < A.rows; i++) {\n    for (let j = 0; j < B.rows; j++) {\n      result.set(i, j, squaredEuclidean(A.getRow(i), B.getRow(j)));\n    }\n  }\n  return result;\n}\n\nfunction range(l: number): number[] {\n  let r: Array<number> = [];\n  for (let i = 0; i < l; i++) {\n    r.push(i);\n  }\n  return r;\n}\n\nfunction cumSum(arr: Array<number>): Array<number> {\n  let cumSum: Array<number> = [arr[0]];\n  for (let i = 1; i < arr.length; i++) {\n    cumSum[i] = cumSum[i - 1] + arr[i];\n  }\n  return cumSum;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}