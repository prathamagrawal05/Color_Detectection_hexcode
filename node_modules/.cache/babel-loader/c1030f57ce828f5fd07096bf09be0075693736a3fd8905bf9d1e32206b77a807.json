{"ast":null,"code":"import { updateClusterID } from './utils';\nexport class KMeansResult {\n  constructor(clusters, centroids, converged, iterations, distance) {\n    this.clusters = clusters;\n    this.centroids = centroids;\n    this.converged = converged;\n    this.iterations = iterations;\n    this.distance = distance;\n  }\n  /**\n   * Allows to compute for a new array of points their cluster id\n   * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n   * @return {Array<number>} - cluster id for each point\n   */\n  nearest(data) {\n    const clusterID = new Array(data.length);\n    return updateClusterID(data, this.centroids, clusterID, this.distance);\n  }\n  /**\n   * Returns the error and size of each cluster\n   * @ignore\n   * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n   * @return {KMeansResult}\n   */\n  computeInformation(data) {\n    let enrichedCentroids = this.centroids.map(centroid => {\n      return {\n        centroid,\n        error: 0,\n        size: 0\n      };\n    });\n    for (let i = 0; i < data.length; i++) {\n      enrichedCentroids[this.clusters[i]].error += this.distance(data[i], this.centroids[this.clusters[i]]);\n      enrichedCentroids[this.clusters[i]].size++;\n    }\n    for (let j = 0; j < this.centroids.length; j++) {\n      let error = enrichedCentroids[j].error;\n      if (enrichedCentroids[j].size && error !== -1) {\n        error /= enrichedCentroids[j].size;\n      } else {\n        enrichedCentroids[j].error = -1;\n      }\n    }\n    return enrichedCentroids;\n  }\n}","map":{"version":3,"names":["updateClusterID","KMeansResult","constructor","clusters","centroids","converged","iterations","distance","nearest","data","clusterID","Array","length","computeInformation","enrichedCentroids","map","centroid","error","size","i","j"],"sources":["/Users/ashraygattani/Documents/most/my-react-app/node_modules/ml-kmeans/src/KMeansResult.ts"],"sourcesContent":["import { updateClusterID } from './utils';\n\nexport interface CentroidWithInformation {\n  centroid: number[];\n  error: number;\n  size: number;\n}\nexport class KMeansResult {\n  /**\n   * Result of the kmeans algorithm\n   * @param clusters - the cluster identifier for each data dot\n   * @param centroids - the K centers in format [x,y,z,...], the error and size of the cluster\n   * @param converged - Converge criteria satisfied\n   * @param iterations - Current number of iterations\n   * @param distance - Distance function to use between the points\n   * @constructor\n   */\n\n  public clusters: number[];\n  public centroids: number[][];\n  public converged: boolean;\n  public iterations: number;\n  public distance: (a: number[], b: number[]) => number;\n  constructor(\n    clusters: number[],\n    centroids: number[][],\n    converged: boolean,\n    iterations: number,\n    distance: (a: number[], b: number[]) => number,\n  ) {\n    this.clusters = clusters;\n    this.centroids = centroids;\n    this.converged = converged;\n    this.iterations = iterations;\n    this.distance = distance;\n  }\n\n  /**\n   * Allows to compute for a new array of points their cluster id\n   * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n   * @return {Array<number>} - cluster id for each point\n   */\n  nearest(data: number[][]): number[] {\n    const clusterID = new Array<number>(data.length);\n    return updateClusterID(data, this.centroids, clusterID, this.distance);\n  }\n\n  /**\n   * Returns the error and size of each cluster\n   * @ignore\n   * @param {Array<Array<number>>} data - the [x,y,z,...] points to cluster\n   * @return {KMeansResult}\n   */\n  computeInformation(data: number[][]): CentroidWithInformation[] {\n    let enrichedCentroids = this.centroids.map((centroid) => {\n      return {\n        centroid,\n        error: 0,\n        size: 0,\n      };\n    });\n\n    for (let i = 0; i < data.length; i++) {\n      enrichedCentroids[this.clusters[i]].error += this.distance(\n        data[i],\n        this.centroids[this.clusters[i]],\n      );\n      enrichedCentroids[this.clusters[i]].size++;\n    }\n\n    for (let j = 0; j < this.centroids.length; j++) {\n      let error = enrichedCentroids[j].error;\n      if (enrichedCentroids[j].size && error !== -1) {\n        error /= enrichedCentroids[j].size;\n      } else {\n        enrichedCentroids[j].error = -1;\n      }\n    }\n\n    return enrichedCentroids;\n  }\n}\n"],"mappings":"AAAA,SAASA,eAAe,QAAQ,SAAS;AAOzC,OAAM,MAAOC,YAAY;EAgBvBC,YACEC,QAAkB,EAClBC,SAAqB,EACrBC,SAAkB,EAClBC,UAAkB,EAClBC,QAA8C;IAE9C,IAAI,CAACJ,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC1B;EAEA;;;;;EAKAC,OAAOA,CAACC,IAAgB;IACtB,MAAMC,SAAS,GAAG,IAAIC,KAAK,CAASF,IAAI,CAACG,MAAM,CAAC;IAChD,OAAOZ,eAAe,CAACS,IAAI,EAAE,IAAI,CAACL,SAAS,EAAEM,SAAS,EAAE,IAAI,CAACH,QAAQ,CAAC;EACxE;EAEA;;;;;;EAMAM,kBAAkBA,CAACJ,IAAgB;IACjC,IAAIK,iBAAiB,GAAG,IAAI,CAACV,SAAS,CAACW,GAAG,CAAEC,QAAQ,IAAI;MACtD,OAAO;QACLA,QAAQ;QACRC,KAAK,EAAE,CAAC;QACRC,IAAI,EAAE;OACP;IACH,CAAC,CAAC;IAEF,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,IAAI,CAACG,MAAM,EAAEO,CAAC,EAAE,EAAE;MACpCL,iBAAiB,CAAC,IAAI,CAACX,QAAQ,CAACgB,CAAC,CAAC,CAAC,CAACF,KAAK,IAAI,IAAI,CAACV,QAAQ,CACxDE,IAAI,CAACU,CAAC,CAAC,EACP,IAAI,CAACf,SAAS,CAAC,IAAI,CAACD,QAAQ,CAACgB,CAAC,CAAC,CAAC,CACjC;MACDL,iBAAiB,CAAC,IAAI,CAACX,QAAQ,CAACgB,CAAC,CAAC,CAAC,CAACD,IAAI,EAAE;;IAG5C,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAChB,SAAS,CAACQ,MAAM,EAAEQ,CAAC,EAAE,EAAE;MAC9C,IAAIH,KAAK,GAAGH,iBAAiB,CAACM,CAAC,CAAC,CAACH,KAAK;MACtC,IAAIH,iBAAiB,CAACM,CAAC,CAAC,CAACF,IAAI,IAAID,KAAK,KAAK,CAAC,CAAC,EAAE;QAC7CA,KAAK,IAAIH,iBAAiB,CAACM,CAAC,CAAC,CAACF,IAAI;OACnC,MAAM;QACLJ,iBAAiB,CAACM,CAAC,CAAC,CAACH,KAAK,GAAG,CAAC,CAAC;;;IAInC,OAAOH,iBAAiB;EAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}