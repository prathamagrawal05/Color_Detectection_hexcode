{"ast":null,"code":"import { squaredEuclidean } from 'ml-distance-euclidean';\nimport { KMeansResult } from './KMeansResult';\nimport { assertUnreachable, validateKmeansInput } from './assert';\nimport { mostDistant, random, kmeanspp } from './initialization';\nimport { updateClusterID, updateCenters, hasConverged, calculateDistanceMatrix } from './utils';\nconst defaultOptions = {\n  maxIterations: 100,\n  tolerance: 1e-6,\n  initialization: 'kmeans++',\n  distanceFunction: squaredEuclidean\n};\nfunction step(centers, data, clusterID, K, options, iterations) {\n  clusterID = updateClusterID(data, centers, clusterID, options.distanceFunction);\n  let newCenters = updateCenters(centers, data, clusterID, K);\n  let converged = hasConverged(newCenters, centers, options.distanceFunction, options.tolerance);\n  return new KMeansResult(clusterID, newCenters, converged, iterations, options.distanceFunction);\n}\n/**\n * Generator version for the algorithm\n * @ignore\n * @param {Array<Array<number>>} centers - K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} data - Points [x,y,z,...] to cluster\n * @param {Array<number>} clusterID - Cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n */\nexport function* kmeansGenerator(data, K, options) {\n  const definedOptions = getDefinedOptions(options);\n  validateKmeansInput(data, K);\n  let centers = initializeCenters(data, K, definedOptions);\n  let clusterID = new Array(data.length);\n  let converged = false;\n  let stepNumber = 0;\n  let stepResult;\n  while (!converged && stepNumber < definedOptions.maxIterations) {\n    stepResult = step(centers, data, clusterID, K, definedOptions, ++stepNumber);\n    yield stepResult;\n    converged = stepResult.converged;\n    centers = stepResult.centroids;\n  }\n}\n/**\n * K-means algorithm\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n * @param {number} [options.maxIterations = 100] - Maximum of iterations allowed\n * @param {number} [options.tolerance = 1e-6] - Error tolerance\n * @param {function} [options.distanceFunction = squaredDistance] - Distance function to use between the points\n * @param {number} [options.seed] - Seed for random initialization.\n * @param {string|Array<Array<number>>} [options.initialization = 'kmeans++'] - K centers in format [x,y,z,...] or a method for initialize the data:\n *  * You can either specify your custom start centroids, or select one of the following initialization method:\n *  * `'kmeans++'` will use the kmeans++ method as described by http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf\n *  * `'random'` will choose K random different values.\n *  * `'mostDistant'` will choose the more distant points to a first random pick\n * @return {KMeansResult} - Cluster identifier for each data dot and centroids with the following fields:\n *  * `'clusters'`: Array of indexes for the clusters.\n *  * `'centroids'`: Array with the resulting centroids.\n *  * `'iterations'`: Number of iterations that took to converge\n */\nexport function kmeans(data, K, options) {\n  const definedOptions = getDefinedOptions(options);\n  validateKmeansInput(data, K);\n  let centers = initializeCenters(data, K, definedOptions);\n  // infinite loop until convergence\n  if (definedOptions.maxIterations === 0) {\n    definedOptions.maxIterations = Number.MAX_VALUE;\n  }\n  let clusterID = new Array(data.length);\n  let converged = false;\n  let stepNumber = 0;\n  let stepResult;\n  while (!converged && stepNumber < definedOptions.maxIterations) {\n    stepResult = step(centers, data, clusterID, K, definedOptions, ++stepNumber);\n    converged = stepResult.converged;\n    centers = stepResult.centroids;\n  }\n  if (!stepResult) {\n    throw new Error('unreachable: no kmeans step executed');\n  }\n  return stepResult;\n}\nfunction initializeCenters(data, K, options) {\n  let centers;\n  if (Array.isArray(options.initialization)) {\n    if (options.initialization.length !== K) {\n      throw new Error('The initial centers should have the same length as K');\n    } else {\n      centers = options.initialization;\n    }\n  } else {\n    switch (options.initialization) {\n      case 'kmeans++':\n        centers = kmeanspp(data, K, options);\n        break;\n      case 'random':\n        centers = random(data, K, options.seed);\n        break;\n      case 'mostDistant':\n        centers = mostDistant(data, K, calculateDistanceMatrix(data, options.distanceFunction), options.seed);\n        break;\n      default:\n        assertUnreachable(options.initialization, 'Unknown initialization method');\n    }\n  }\n  return centers;\n}\nfunction getDefinedOptions(options) {\n  return {\n    ...defaultOptions,\n    ...options\n  };\n}","map":{"version":3,"names":["squaredEuclidean","KMeansResult","assertUnreachable","validateKmeansInput","mostDistant","random","kmeanspp","updateClusterID","updateCenters","hasConverged","calculateDistanceMatrix","defaultOptions","maxIterations","tolerance","initialization","distanceFunction","step","centers","data","clusterID","K","options","iterations","newCenters","converged","kmeansGenerator","definedOptions","getDefinedOptions","initializeCenters","Array","length","stepNumber","stepResult","centroids","kmeans","Number","MAX_VALUE","Error","isArray","seed"],"sources":["/Users/ashraygattani/Documents/most/my-react-app/node_modules/ml-kmeans/src/kmeans.ts"],"sourcesContent":["import { squaredEuclidean } from 'ml-distance-euclidean';\n\nimport { KMeansResult } from './KMeansResult';\nimport { assertUnreachable, validateKmeansInput } from './assert';\nimport { mostDistant, random, kmeanspp } from './initialization';\nimport {\n  updateClusterID,\n  updateCenters,\n  hasConverged,\n  calculateDistanceMatrix,\n} from './utils';\n\nconst defaultOptions = {\n  maxIterations: 100,\n  tolerance: 1e-6,\n  initialization: 'kmeans++' as InitializationMethod,\n  distanceFunction: squaredEuclidean,\n};\n\n/**\n * Each step operation for kmeans\n * @ignore\n * @param {Array<Array<number>>} centers - K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} data - Points [x,y,z,...] to cluster\n * @param {Array<number>} clusterID - Cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n * @param {number} iterations - Current number of iterations\n * @return {KMeansResult}\n */\n\nexport type InitializationMethod = 'kmeans++' | 'random' | 'mostDistant';\nexport interface OptionsWithDefault {\n  distanceFunction?: (p: number[], q: number[]) => number;\n  tolerance?: number;\n  initialization?: InitializationMethod | number[][];\n  maxIterations?: number;\n}\n\nexport interface OptionsWithoutDefault {\n  seed?: number;\n}\n\nexport type Options = OptionsWithDefault & OptionsWithoutDefault;\ntype DefinedOptions = Required<OptionsWithDefault> & OptionsWithoutDefault;\n\nfunction step(\n  centers: number[][],\n  data: number[][],\n  clusterID: number[],\n  K: number,\n  options: DefinedOptions,\n  iterations: number,\n): KMeansResult {\n  clusterID = updateClusterID(\n    data,\n    centers,\n    clusterID,\n    options.distanceFunction,\n  );\n  let newCenters: number[][] = updateCenters(centers, data, clusterID, K);\n  let converged = hasConverged(\n    newCenters,\n    centers,\n    options.distanceFunction,\n    options.tolerance,\n  );\n  return new KMeansResult(\n    clusterID,\n    newCenters,\n    converged,\n    iterations,\n    options.distanceFunction,\n  );\n}\n\n/**\n * Generator version for the algorithm\n * @ignore\n * @param {Array<Array<number>>} centers - K centers in format [x,y,z,...]\n * @param {Array<Array<number>>} data - Points [x,y,z,...] to cluster\n * @param {Array<number>} clusterID - Cluster identifier for each data dot\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n */\nexport function* kmeansGenerator(\n  data: number[][],\n  K: number,\n  options: Options,\n) {\n  const definedOptions = getDefinedOptions(options);\n  validateKmeansInput(data, K);\n  let centers = initializeCenters(data, K, definedOptions);\n  let clusterID: number[] = new Array(data.length);\n\n  let converged = false;\n  let stepNumber = 0;\n  let stepResult;\n  while (!converged && stepNumber < definedOptions.maxIterations) {\n    stepResult = step(\n      centers,\n      data,\n      clusterID,\n      K,\n      definedOptions,\n      ++stepNumber,\n    );\n    yield stepResult;\n    converged = stepResult.converged;\n    centers = stepResult.centroids;\n  }\n}\n\n/**\n * K-means algorithm\n * @param {Array<Array<number>>} data - Points in the format to cluster [x,y,z,...]\n * @param {number} K - Number of clusters\n * @param {object} [options] - Option object\n * @param {number} [options.maxIterations = 100] - Maximum of iterations allowed\n * @param {number} [options.tolerance = 1e-6] - Error tolerance\n * @param {function} [options.distanceFunction = squaredDistance] - Distance function to use between the points\n * @param {number} [options.seed] - Seed for random initialization.\n * @param {string|Array<Array<number>>} [options.initialization = 'kmeans++'] - K centers in format [x,y,z,...] or a method for initialize the data:\n *  * You can either specify your custom start centroids, or select one of the following initialization method:\n *  * `'kmeans++'` will use the kmeans++ method as described by http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf\n *  * `'random'` will choose K random different values.\n *  * `'mostDistant'` will choose the more distant points to a first random pick\n * @return {KMeansResult} - Cluster identifier for each data dot and centroids with the following fields:\n *  * `'clusters'`: Array of indexes for the clusters.\n *  * `'centroids'`: Array with the resulting centroids.\n *  * `'iterations'`: Number of iterations that took to converge\n */\nexport function kmeans(data: number[][], K: number, options: Options) {\n  const definedOptions = getDefinedOptions(options);\n\n  validateKmeansInput(data, K);\n  let centers = initializeCenters(data, K, definedOptions);\n\n  // infinite loop until convergence\n  if (definedOptions.maxIterations === 0) {\n    definedOptions.maxIterations = Number.MAX_VALUE;\n  }\n\n  let clusterID: number[] = new Array(data.length);\n  let converged = false;\n  let stepNumber = 0;\n  let stepResult;\n  while (!converged && stepNumber < definedOptions.maxIterations) {\n    stepResult = step(\n      centers,\n      data,\n      clusterID,\n      K,\n      definedOptions,\n      ++stepNumber,\n    );\n    converged = stepResult.converged;\n    centers = stepResult.centroids;\n  }\n  if (!stepResult) {\n    throw new Error('unreachable: no kmeans step executed');\n  }\n  return stepResult;\n}\n\nfunction initializeCenters(\n  data: number[][],\n  K: number,\n  options: DefinedOptions,\n) {\n  let centers: number[][];\n  if (Array.isArray(options.initialization)) {\n    if (options.initialization.length !== K) {\n      throw new Error('The initial centers should have the same length as K');\n    } else {\n      centers = options.initialization;\n    }\n  } else {\n    switch (options.initialization) {\n      case 'kmeans++':\n        centers = kmeanspp(data, K, options);\n        break;\n      case 'random':\n        centers = random(data, K, options.seed);\n        break;\n      case 'mostDistant':\n        centers = mostDistant(\n          data,\n          K,\n          calculateDistanceMatrix(data, options.distanceFunction),\n          options.seed,\n        );\n        break;\n      default:\n        assertUnreachable(\n          options.initialization,\n          'Unknown initialization method',\n        );\n    }\n  }\n  return centers;\n}\n\nfunction getDefinedOptions(options: Options): DefinedOptions {\n  return { ...defaultOptions, ...options };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}